## 依赖注入

一般来讲，一个对象有三种方式获取到它的依赖：

- 依赖可以直接被创建
- 依赖可以作为全局变量被追溯或引用
- 依赖可以作为参数被传入

使用依赖注入，我们可以实现第三种获取依赖的方式(其他两种方式实现起来有一些难度，例如污染全局作用域以及使isolation几乎不可能)。依赖注入是一种设计模式，使用依赖注入可以移除那些硬编码的依赖，而且使得我们在运行时移除或者改变他们成为可能。

这种可以在运行时修改依赖的能力允许我们创建隔离环境，隔离环境非常有利于代码的测试。我们可以将生产环境中使用的真实对象替换为mock对象从而在测试环境中运行。

从原理上讲，这种设计模式会在需要时自动提前追溯并获取到依赖资源，并将获取到的依赖资源注入到目标。

在我们写依赖于其他对象或者库的组件时，我们需要列出其依赖。在运行时，注入器会创建依赖的实例并将其传给目标。

*注意：在上面的示例代码中，我们在全局作用域中创建了一个控制器，这绝不是一个好主意。我们这样做只是为了提供一个简明的示例。*

在运行时，SomeClass 并不关心它是如何得到 greeter 依赖的，只要能得到就可以了。为了将 greeter 传入 SomeClass，SomeClass 的创建者会负责在创建 SomeClass 时把其所依赖的对象传进来。

基于以上原因，Angular 使用 $injector 来管理追溯和初始化依赖资源。事实上，$injector 负责初始化所有 Angular 的组件，包括我们自己创建的应用的模块，指令，控制器等等。

在运行时，当我们创建的任何一个组件启动时，注入器负责真正的初始化该组件对象并将其传入到所有依赖它的对象中。

举例来说，下面这个简单的应用声明了一个简单的模块和一个简单的控制器，如下：

在运行时，当 Angular 初始化我们的模块实例时，它将追溯到 greeter 并仅仅将其传入即可

在幕后，Angular 实际做了以下事情：