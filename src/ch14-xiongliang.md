## 依赖注入

一般来讲，一个对象有三种方式获取到它的依赖：

- 依赖可以直接被创建
- 依赖可以作为全局变量被追溯或引用
- 依赖可以作为参数被传入

使用依赖注入，我们可以实现第三种获取依赖的方式(其他两种方式实现起来有一些不足，例如污染全局作用域以及使隔离几乎不可能)。依赖注入是一种设计模式，使用依赖注入可以移除硬编码的依赖，而且使得我们在运行时移除或者改变依赖成为可能。

这种可以在运行时修改依赖的能力允许我们创建隔离环境，隔离环境非常有利于代码的测试。我们可以将生产环境中使用的真实对象替换为mock对象从而在测试环境中运行。

从原理上讲，这种设计模式会在需要时自动提前追溯并获取到依赖资源，并将获取到的依赖资源注入到目标。

在我们写依赖于其他对象或者库的组件时，我们需要列出其依赖。在运行时，注入器会创建依赖的实例并将其传给目标。

*注意：在上面的示例代码中，我们在全局作用域中创建了一个控制器，这绝不是一个好主意。我们这样做只是为了提供一个简明的示例。*

在运行时，SomeClass 并不关心它是如何得到 greeter 依赖的，只要能得到就可以了。为了将 greeter 传入 SomeClass，SomeClass 的创建者会负责在创建 SomeClass 时把其所依赖的对象传进来。

基于以上原因，Angular 使用 $injector 来管理追溯和初始化依赖资源。事实上，$injector 负责初始化所有 Angular 的组件，包括我们自己创建的应用的模块，指令，控制器等等。

在运行时，当我们创建的任何一个组件启动时，注入器负责真正的初始化该组件对象并将其传入到所有依赖它的对象中。

举例来说，下面这个简单的应用声明了一个简单的模块和一个简单的控制器，如下：

Angular 在运行时开始初始化我们的模块实例时，它将追溯到 greeter，并将其作为参数传入：

在幕后，Angular 实际做了以下事情：

在上面的示例中，我们没有在任何地方指定如何找到 greeter；而它就是可用的，因为注入器帮我们找到并引入我们所需的依赖。

在初始化过程中，AngularJS 使用一个叫 annotate 的函数来将传入一个函数的参数列表分解。要知道 annotate 如何使用，你可以在 Chrome 开发者工具中输入以下内容：

在每一个 Angular 应用中，$injector 都在后台工作着，无论我们是否知道它。当我们创建一个不带 [] 显式标记的控制器或者使用显式方式设置参数时，$injector 会基于参数的名称来推断和查找依赖。

### 推断标记

Angular 假设函数参数名就是依赖的名称，除非另行说明。因此，Angular 会对该函数调用 toString() 方法，解析并提取函数的参数列表，然后使用 $injector 将依赖注入到函数中。

注入过程看起来是这样的：

注意这个过程只有在没有被最小化，没有被混淆的代码中才能工作，因为 Angular 需要完整的参数列表。

使用这种 JavaScript 推断，顺序是不重要的：Angular 将为我们解决这个问题，它会按照参数顺序正确的将依赖注入。

*JavaScript 代码最小化工具一般会将函数参数的名字长度减少到最小(另外还有去掉无用的空格，无用的换行以及注释等)以减小最终生成的 JavaScript 文件大小。如果没有明确无误的参数名，Angular 将不能推断参数归属也无法推断出需要注入什么了。*

### 显式标记

Angular 为我们提供了一种显式定义函数在调用时所需依赖的方法。这种方法允许代码最小化工具重命名函数参数名，重命名后注入依然可以正常工作。

注入过程使用 $inject 属性来标记函数。一个函数的 $inject 属性是一个数组，数组由作为依赖被注入的服务名称组成。

要使用 $inject ，需要将其设置为函数的属性。

使用这种标记风格，声明依赖的顺序很重要，因为 $inject 这个数组中元素的顺序必须和函数中参数的顺序一致才能保证正确注入。使用这种注入方式的代码可以被最小化，因为标记信息在压缩前已经被记录了。

### 行内标记

行内标记是 Angular 提供的最后一种标记方法。这个语法糖工作原理与上面 $inject 显示标记函数一致，但是这种方法允许我们在定义函数的同时定义被注入的依赖名称。并且在定义过程中不需要使用临时变量

行内标记允许我们在定义 Angular 对象时传入数组而不是函数。数组的元素是由可注入依赖的名称字符串列表最后再加上对象定义函数所组成的。

例如：

行内标记方法支持代码最小化工具，因为我们传入的是字符串数组。我们通常将这种标记方法叫做方括号标记或者数组标记 []。

### $inject 接口

虽然一般情况下我们不会直接用到 $injector，但是了解 $inject 接口能使我们更了解其工作原理。

#### annotate()

annotate() 返回在函数初始化时将被注入到函数中的服务名称的数组。annotate() 被注入器调用以确定哪些服务在启动时将被注入。

annotate() 函数有一个参数：

- fn (函数或者数组)

参数 fn 是一个函数定义或者是一个方括号标记数组。

annotate() 函数返回在启动时将被注入的服务的名称数组。

你可以在 Chrome 调试工具中自己尝试。

#### get()

get() 方法接受一个参数并返回服务的实例。

- name (string)

参数 name 是我们希望得到的服务实例名称。

get() 返回 name 指定的服务的实例。

#### has()

has() 方法在被请求的服务已经被注入器注册时返回 true，否则返回 false。它接受一个参数：

- name (string)

name 是被请求的服务的名称。

#### instantiate()

instantiate() 方法创建一个新的 JavaScript 类型的实例。它使用了一个构建函数，并且调用 new 操作符将所有指定参数传入。它接受两个参数：

- Type (function)

Type 是将被 调用的(invoke，参考下面的 invoke() 介绍) 的构建函数。

- locals (object - optional)

这个可选参数为我们提供了另外一种在函数调用时从函数参数名获取依赖的方式。

instantiate() 方法返回 Type 的一个新的实例。


#### invoke()

invoke() 方法将调用一个函数，并将从 $injector 获取到的依赖作为参数传入该函数。

invoke() 方法接受三个参数：

- fn (function)

fn 为将被调用的函数。函数的参数是通过标记的方式设置的。

- self (object - optional)

self 允许我们设置被调用函数的上下文

- locals (object - optional)

这个可选参数为我们提供了另外一种在函数调用时从函数参数名获取依赖的方式。

invoke() 方法返回调用 fn 函数时所返回的结果。

### ngMin

上面介绍了三种定义标记的方法，你一定要注意在定义函数时这三种方法都是可用的。但是在生产环境中，如果我们总是要关心代码中参数的顺序或者代码膨胀会是十分痛苦的事情。

一个叫做 ngMin 的工具允许我们不用再去明确的定义所需要的依赖。ngMin 是为 Angular 应用做代码最小化之前预先做处理的工具。它会遍历 Angular 应用的代码并为我们将注入依赖设置好。

例如，它会将如下代码：

转换为如下代码：

ngMin 显著节省了我们输入代码的时间并且清理了我们的源文件。

### Installation

我们将使用 npm 包管理器来安装 ngMin：

*如果我们正在使用 Grunt，我们可以安装一个叫做 grunt-ngmin 的 Grunt 任务。如果我们正在使用 Rails，我们可以使用 Ruby gem ngmin-rails。*

### 使用 ngMin

我们可以在命令行工具中单独使用 ngMin。在命令行中使用需要传入两个参数：输入的文件 input.js 和输出的文件 output.js。或者通过标准输入输出程序，如下：

input.js 是我们的源文件，output.js 是标记后的输出文件。

### ngMin 工作原理

ngMin 的核心工作原理是使用了抽象语法树来遍历 JavaScript 源文件。ngMin 使用一个叫做 astral 的 AST 工具框架重建源代码并重写必要的标记，最后使用 escodegen 将新的源代码输出。

ngMin 要求我们的 Angular 源代码使用普通的合乎逻辑的函数定义方式。如果我们使用与本书相似的语法，ngMin 将可以正常工作。
