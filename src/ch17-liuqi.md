###XHR in Practice####Cross-Origin and Same-Origin PolicyWeb browsers nearly universally prevent web pages from fetching and executing scripts on foreign domains.
所有的Web浏览器几乎都会防止网页抓取和执行外域的脚本.
The same-origin policy specifically permits scripts to run on pages that originate from the same site. Our browser identifies a page with the same origin by comparing the scheme, hostname, and port number of both pages. There are heavy run restrictions on any other interactions with scripts originating from off-site.

同域策略是仅允许来自相同站点脚本的在页面上运行.浏览器通过比较两个页面的协议(scheme),主机名(hostname)和端口号(port number)来判断它们是否同域.浏览器对从不同的域发起的交互脚本有着严格的限制.The Cross Origin Resource Sharing (or CORS, for short) is often a source of headaches for fetching data over XHR and dealing with foreign sources.

在通过XHR请求数据或者处理外部资源时,跨域资源共享(Cross Origin Resource Sharing,以下简写为CORS)经常是一件让人头痛的事情.Fortunately, there are several ways for us to get data that is exposed by external data sources into our app. We’ll look at two of these methods and mention a third (that requires a bit more backend support):

幸运的是,有几种方法可以在我们的应用里获取外部暴露的数据.我们来详细看看其中的两个方法和简述的第三种方法(需要更多的后端的支持):

- JSONP- CORS- Server proxies
####JSOP
JSONP is a way to get past the browser security issues that are present when we’re trying to request data from a foreign domain. In order to work with JSONP, the server must be able to support the method.
当我们尝试请求外域数据的时候,JSONP是一种绕过浏览器同域策略实现跨域访问的方法.为使得JSONP能够工作,服务端也必须支持该方法.
JSONP works by issuing a GET request using a `<script>` tag, instead of using XHR requests. The JSONP technique creates a `<script>` tag and places it in the DOM. When it shows up in the DOM, the browser takes over and requests the script referenced in the src tag.

与使用XHR请求不同,JSONP是利用`<script>`标签发送GET请求来工作的.JSONP技术创建了`<script>`标签并且将它放在DOM中.当它出现在DOM中时,浏览器接下来请求在src标记中引用的脚本.

When the server returns the request, it surrounds the response with a JavaScript function invocation that corresponds to a request about which our JavaScript knows.

Angular provides a helper for JSONP requests using the $http service. The jsonp method of request through the $http service looks like:当服务端接收请求并返回时,它会在响应外包装一个javascript函数调用,对应于我们javascript已知的一个请求.Angular给使用$http service的JSONP请求提供帮助.
When we make this call, Angular places a `<script>` tag on the DOM that might look something like:
当我们使用这个调用时,Angular像下面一样在DOM中插入了一个`<script>`标签:
Notice that Angular has replaced the JSON_CALLBACK with a custom function that Angular creates specifically for this request.
When the data comes back from the JSONP-enabled server, it is wrapped in the anonymous function automatically generated by Angular angular.callbacks._0.
In this case, the GitHub server will return some JSON wrapped in the callback, and its response might look like:注意Angular已经用一个Angular为这个请求创建的自定义函数取代了JSON_CALLBACK.

当数据从支持JSONP的服务端传回时,它被包裹在Angular的angular.callbacks._0自动生成的匿名函数中.在这种情况下，GitHub的服务器会返回一些包裹在回调中的JSON，应答可能如下：When Angular calls the special function, it resolves the $http promise.
`当Angular调用回调函数,it resolves the $http promise`.
When we write our own back-end servers to support JSONP, we need to ensure that, when we respond, we wrap the data inside the function given by the request with callback.当我们编写我们自己的后端服务器来支持JSONP,我们需要确保当我们响应请求时,需要将数据包裹在请求提供的callback函数中.
When using JSONP, we need to be aware of the potential security risks. First, we’re opening up our server to allow a back-end server to call any JavaScript in our app.

在使用JSONP时,我们需要意识到潜在的安全风险.首先,我们开放了我们的服务器,允许后端服务器调用我们应用中的任意javascript代码.
A foreign site that we do not control can change its script at any time (or a malicious cracker could), exposing our site for vulnerabilities. The server or a middleman could potentially send extra JavaScript logic back into our page that could expose private user data.一个我们无法控制的外部网站可能在任何时候修改它的script代码(或者被恶意的黑客修改),暴露我们网站的漏洞.服务器或者一个中间人也有可能会发送额外的javascript逻辑到我们的网页中,暴露用户的私人数据.

We can only use JSONP to send GET requests, since we’re setting a GET request in the `<script>` tag. Additionally, it’s tough to manage errors on a script tag. We should use JSONP sparingly and only with servers we trust and control.

我们只可以使用JSONP发送get请求,因为我们在`<script>`标签中设置了一个GET请求.此外,在一个script标签中处理异常是非常困难的.我们应该只在可以信赖和控制的服务器上谨慎的使用JSONP.
####Using CORS
In recent years, the W3C has created the CORS specification, or Cross Origin Resource Sharing policy, to replace the JSONP hack in a standard way.
The CORS specification is simply an extension to the standard XMLHttpRequest object that allows JavaScript to make cross-domain XHR calls. It does so by preflighting a request to the server to effectively ask for permission to send the request.
This preflight gives the receiving server the ability to accept or reject any request from all servers, a select server, or set of servers. That means that both the client app and the server app need to coordinate to provide data to the client/server.
The W3C wrote the CORS specification with the intention of abstracting away many of the details from the client-side developer so that it appears as though the request is made in the same way as a same-origin request.
近年来，W3C制定了CORS规范(Cross Origin Resource Sharing)，希望以一种标准的方式来取代JSONP hack。
CORS规范仅仅是一种对标准XMLHttpRequest对象的扩展，这种扩展允许JavaScript执行跨域的XHR回调。通过预检发送到服务端的request请求，来更加高效的获取发送request请求的许可。
这种预检使得接收端的服务器可以接受或者拒绝来自所有服务器、选定的服务器或者一组服务器的请求。这意味着无论是服务端应用还是客户端应用，都需要协调给 服务端/客户端 提供数据。
W3C制定CORS标准，意在抽象掉来自客户端开发者的很多细节，使得这种请求的制造方式跟一个类似的原始请求一样。